# 技术方案评审

关于技术方案评审本身：

1. 如何能更好的呈现技术方案设计？呈现哪些要素？
2. 遵照的一些原则：客观、可观测的、可操作的；
3. 抓大放小（2/8）

* 作为技术方案提出者：
* 作为技术方案评审者：

前端和后端技术方案评审不一样的地方：

后端：客观的、可观测的、模块的输入输出、数据的存储；
前端：部分客观、不可观测。前端是将数据/状态映射至 UI 样式，而 UI 样式对于代码的设计影响较大，需要在实际写代码过程当中才能设计。所以评审的切入点应该是在已经开始开发的初期，而非写代码之前；

后端的唯一完整应用状态只需要抽象成有限的领域模型然后建表即可，而前端要将页面状态考虑进去的话，实际上很难抽象。反而是MVVM的VM，在最频繁变化的那一层有着极强表现力和灵活性。

## 需求说明（总结文字）

本次需求是技术改造还是业务需求？为了解决什么问题？或者达到什么效果？

## 需求影响面（总结文字）

明确本次需求影响范围：

* 是否影响了项目当中其他业务代码功能；
* 是否影响了上下游产品；
* 对于埋点数据是否有影响；
* 对于接口数据传参是否有影响；
* 是否需要对基础建设做改造；

## 概要设计（画图&文字说明）

* 前端页面投放了渠道；
* 产品衔接的上下游有哪些；
* 接入了哪些非团队内部维护的功能模块；
* 对接了哪些后端服务模块；
* 后端服务模块之间是如何交互的；
* 前后端是如何进行交互；
* 业务术语说明（中、英文缩写）；

## 用户交互关键路径（流程图&设计稿）

在状态扭转路径图（产品角度）上加入核心交互路径（用户角度）

## 接口设计（链接展示）

1. 接口文档

* 一共多少个接口，每个接口的用途；

2. 响应

* 嵌套数据类型（>= 3层场景）
* 数据冗余(返回了不需要的字段数据)
* 空值返回类型约定

## 组件拆分、复用设计（画图+代码展示）


* 每个页面的数据流向；
* 每个页面的组件总体拆分(1 ~ 2 级)及依赖关系，展示页面的视图结构+逻辑结构；（画图）
* 某个组件被复用的次数 > 2，展示组件如何设计、状态如何维护；（画图）
* 组件之间的通讯依赖层级(event propagation) >= 2层，展示组件之间的逻辑结构；（画图）
* 存在非父子组件之间的依赖关系，展示组件之间的逻辑结构；（画图）
* 组件之间的通讯除了 Props+Events 模式之外（例如 Provide/eject、Store 管理的响应式数据、单独管理数据的模块、Rxjs 等），如果有其他的通讯方式展示它们之间的逻辑关系+代码；（画图+代码）
* ~~* StateManager 设计（例如 Store 管理的响应式数据，单独管理数据的模块），展示逻辑关系+代码；（画图+代码）~~
* Root Component/Page 的状态+行为（代码展示）

没有银弹，由实际所要解决的问题所决定。

----

一些说明：

**组件的拆分和复用不是同一个概念。拆分不一定会被复用，核心的目的也不一定是为了复用（例如一个单文件超过了500行的代码，可以考虑将部分代码做拆分，使得代码的结构更加清晰，阅读起来心智负担更小），而被复用的组件一般是经过一定设计和抽象之后做的拆分。**

前端写页面实际上就是拆组件，拆组件实际上就是管理状态，在 mvvm 框架的加持下，充分理解并运用：**状态驱动视图**：

UI = Function(State)

<!-- 一个非常简单的例子（以 Vue 为例），定义一个响应式数据，并在 template 模板当中使用，那么当这个响应式数据发生变化的时候会自动触发模板的重新渲染。状态驱动视图这样的理念极大的提升了我们的开发效率，让我们摆脱了之前需要手动去操作 DOM 元素控制视图，更加专注于业务逻辑的开发。

状态（数据）包含状态（数据）本身以及改变状态（数据）的行为。

对于 data，props，computed 数据 => 状态

对于 methods => 行为 -->

当拿到一份设计稿开始着手组件设计的时候，首先需要建立起的概念就是定义状态+行为，状态+行为决定视图的变化。

在项目开发初期，大家可能关注的点更多在于视图层所体现出的结构。依据设计稿会有更加直观的组件模块的拆解，这个时候页面/组件状态数据还没有非常明确的定义，缺少对于数据模型的关注（可能后端接口还没ready，前端同学最好是作为设计方站在整个产品视角去梳理用户交互、状态扭转关键路径，得出数据模型）

在组件通讯这块，常规的做法： Props+Events 方式可以满足大部分的组件拆分和开发需求：

但是一旦组件拆分过细过深（对于纯渲染组件还好，涉及到状态变更的场景就变的复杂起来，>= 2层的组件通讯就比较复杂了）或者多个组件之间的状态共享，这种模式就显得捉襟见肘。

Case1:


在营销活动的场景里面：散落在页面当中的任何一个组件都可能会修改页面分享配置（由于小程序的开发限制，页面的分享必须是在 Page 当中完成）。以前的做法是各组件通过 event 层层冒泡，直到 Page 页面组件响应分享的事件，然后去完成相关配置更新操作，那么这种方式有什么缺点呢：

* 组件间耦合程度高，强依赖上层组件捕获并透传事件；
* 组件/模块间通讯依赖路径过长；
* 将原本各分享模块处理的配置逻辑收敛至 Page 当中的分享逻辑耦合不同类型（实际不需要），分支逻辑判断多；

核心所要解决的问题：各组件更新页面的分享配置。


```javascript
// shareStateManager.js
let shareConfig = {}

export const shareStateManager = {
  setConfig() {
    // do something
  },
  getConfig() {
    // do something
  },
  beforeShareAction() {
    // do something
  },
  afterShareAction() {
    // do something
  }
}
```

* 组件之间的通讯依赖路径为1；
* 将原本收敛在 Page 当中处理的分享逻辑拆解到触发分享动作的节点；
* StateManager 统一管理分享的状态和行为；

Case2:

在营销活动当中：散落在页面当中任何一个组件都可能会触发页面的弹窗，为了组件的复用会将弹窗进行一定程度的封装。


和 case1 不一样的地方是，case1 更多的是组件的拆分/封装所带来的逻辑层代码的影响，和视图层的关系不大。而在 case2 当中，组件拆分/封装不仅带来了逻辑层代码通讯的影响，同时对于视图层的渲染也带来的一定的挑战。


这种场景所要解决的核心问题：

* 弹窗自身相关；
  * 展示/关闭逻辑；
  * 视图渲染；
* 弹窗和其他模块/组件之间的逻辑交互；

目前的处理方式：

1. BasePopup 不杂糅业务逻辑；暴露接口让外部可控制展示；关闭时抛出关闭事件以及业务 Popup 组件 Key；
2. BasePopup 提供 slot 插槽用以业务 Popup 组件拓展；
3. 业务 Popup 抛出事件，统一收敛至 Page 页面进行处理；

各组件实际是要和业务 Popup 交互，统一收口到了不是那么强关联的 Page 进行处理：

* 组件之间通讯依赖路径长；（父子、爷孙、无关联节点都走 Props+event 通讯，收敛至 Root）
* $refs API 调用不灵活，Popup 管理松散；
* 原本应该属于 Popup 内部处理的逻辑强耦合至 Page，需要做各种 Popup type 的判断做分支逻辑处理；


那么针对此种情况依赖引入 StateManager 进行管理。和 case1 的 StateManager 不一样的地方是和视图层有了联系，这里其实可以非常自然的联想到使用 Store 来实现 StateManager。还是利用 mvvm 的思想，Store 当中的数据为响应式数据，可以驱动视图依赖进行渲染更新。

这里需要明确的一个点就是：Store 适用的场景非常宽泛。并不是说只有全局数据才能放到 Store 里面，任何依赖路径过长的通讯场景、多组件状态共享都可以使用。

```javascript
// popupStateManager.js
import { createStore } from '@mpxjs/core'

let eventHandler = null
const noop = () => {}
export const popupStateManager = createStore({
  state: {
    type: '',
    visible: false,
    data: {}
  },
  mutations: {
    showPopup(store, payload) {
      Object.assign(store.state, payload, { visible: true })
      eventHandler = payload.eventHandler || noop
    },
    hidePopup(({ state })) {
      state.visible = false
    }
  },
  actions: {
    handleEvent() {
      eventHandler()
    }
  }
})
```

```javascript
<template>
  <component is="{{ type }}" visible="{{ visible }}" data="{{ data }}" bindevent="handlePopupEvent"></component>
</template>

<script>
import { createComponent } from '@mpxjs/core'
import popupStateManager from 'popupStateManager'

createComponent({
  computed: {
    ...popupStateManager.state(['visible', 'data', 'type'])
  },
  methods: {
    handlePopupEvent() {
      this.handleEvent()
    },
    ...popupStateManager.action(['handleEvent'])
  }
})
</script>
```

* 组件之间的通讯依赖路径为1；
* 将原本耦合至 Page 当中的逻辑拆解到各自的业务 Popup 当中自行去处理，Page 代码量大幅减少；
* StateManager 统一管理 Popup 的展示/关闭逻辑；

对于这一整个页面来说，页面的状态和行为决定了整个页面的渲染（对于 Vue 来说没有页面的概念，只有 Component，一个页面其实就是 Root Component）。对于这个页面所包含的任何一个组件来说同样也适用：组件自身的状态和行为决定了这个组件渲染。

## 目录结构（代码展示）

介绍项目的目录结构划分

* src
  * api
  * assets
  * pages
  * components
  * common
    * js
    * stylus

----
 
目标：

* 结构划分是否清晰
* 依赖文件好找

## 公共模块（代码展示）

* src/common 相关的代码，介绍各模块的作用。

----

目标：

* 如果已经有相关实现好的基础能力，能复用的代码就不要单独实现；
* 可沉淀的基础能力考虑收敛至 sdk 内部；


## 项目排期

1. 前端各模块开发人力及排期


2. 项目总体排期


## 会议纪要

记录本次技术方案评审所提的问题


----

* 技术评审要达到的效果是能够让没做过这个需求的人，看完技术方案，可以很快的明白技术架构；
* 多画图少文字；（看写的文字还不如看代码）
* 代码的复杂度和代码的长度没必然关系
