技术方案评审

## 需求说明

本次的开发内容是解决什么问题？技术改造？业务需求？

## 概要设计

全局观，例如奖励体系，系统之间如何交互。业务术语（中、英文缩写）

前端页面作为用户所接触到的最为直观的载体。在页面背后实际所对接的系统服务多，数据扭转，存储都在不同地方。有必要去了解一个用户在使用产品过程中到底有哪些实际进行交互的系统。

有多少个后端系统服务对接？它们之间的关系是什么？它们和前端是如何交互的？

todo：举一个例子：准入场景

todo：健康码相关

## 需求影响面

明确本次需求改动是否会影响到其他功能模块及上下游系统。


todo: 关于这一点的QA测试说明

todo: 一个图
大到整个产品流程；
小到模块代码当中某一行代码、某一个字段的修改；

todo：case

## 用户交互、状态扭转关键路径

站在业务视角去审视用户交互、状态扭转。（和数据埋点也比较大的关系）

业务视角：

招募准入：

用户交互

* leads 获取率
* 准入漏斗转化率

状态扭转

todo：准入场景

todo：裂变相关

## 边界收敛

哪些设计可以现在做，哪些可以以后再做；哪些在前端做，哪些放到后端来做

配置化

* 前后端可能都有逻辑判断用户是否能参与活动；（前后端都维护了判断逻辑）
* 异常状态的判断；
* 前端状态映射；
* 复合状态、计算逻辑过多；

前端偏渲染、复合状态、后端收敛数据状态（最短依赖路径）


todo：

1. 数据模型：响应式数据、静态数据

响应式数据按需使用。

## 接口设计？

嵌套数据类型，数据冗余，空值返回类型约定）

## 组件拆分、复用设计：重点，直接影响了代码质量（业务组件 -> 页面的拆解）

* 页面组件总体拆分
* 组件之间的通讯依赖层级(events) >= 2层
* 多对一的组件/模块依赖场景


前端写页面实际上就是拆组件，拆组件实际上就是管理状态，在 mvvm 框架的加持下，充分理解并运用：**状态驱动视图**：

UI = Function(State)

没有银弹，由实际所要解决的问题所决定。

一个非常简单的例子（以 Vue 为例），定义一个响应式数据，并在 template 模板当中使用，那么当这个响应式数据发生变化的时候会自动触发模板的重新渲染。状态驱动视图这样的理念极大的提升了我们的开发效率，让我们摆脱了之前需要手动去操作 DOM 元素控制视图，更加专注于业务逻辑的开发。

状态（数据）包含状态（数据）本身以及改变状态（数据）的行为。

对于 data，props，computed 数据 => 状态
对于 methods => 行为

当拿到一份设计稿开始着手组件设计的时候，首先需要建立起的概念就是定义状态+行为，状态+行为决定视图的变化。

在项目开发初期，大家可能关注的点更多在于视图层所体现出的结构。依据设计稿会有更加直观的组件模块的拆解，这个时候页面/组件状态数据还没有非常明确的定义，缺少对于数据模型的关注（可能后端接口还没ready，前端同学最好是作为设计方站在整个产品视角去梳理用户交互、状态扭转关键路径，得出数据模型）

在组件通讯这块，常规的做法： Props+Events 方式可以满足大部分的组件拆分和开发需求：

todo: 图

但是一旦组件拆分过细过深（对于纯渲染组件还好，涉及到状态变更的场景就变的复杂起来，>= 2层的组件通讯就比较复杂了）或者多个组件之间的状态共享，这种模式就显得捉襟见肘。

Case1:

在营销活动的场景里面：散落在页面当中的任何一个组件都可能会修改页面分享配置（由于小程序的开发限制，页面的分享必须是在 Page 当中完成）。以前的做法是各组件通过 event 层层冒泡，直到 Page 页面组件响应分享的事件，然后去完成相关配置更新操作，那么这种方式有什么缺点呢：

* 组件间耦合程度高，强依赖上层组件捕获并透传事件；
* 组件/模块间通讯依赖路径过长；
* 将原本各分享模块处理的配置逻辑收敛至 Page 当中的分享逻辑耦合不同类型（实际不需要），分支逻辑判断多；

核心所要解决的问题：各组件更新页面的分享配置。

StateManager

```javascript
// shareStateManager.js
let shareConfig = {}

export const shareStateManager = {
  setConfig() {
    // do something
  },
  getConfig() {
    // do something
  },
  beforeShareAction() {
    // do something
  },
  afterShareAction() {
    // do something
  }
}
```

* 组件之间的通讯依赖路径为1；
* 将原本收敛在 Page 当中处理的分享逻辑拆解到触发分享动作的节点；
* StateManager 统一管理分享的状态和行为；

Case2:

在营销活动当中：散落在页面当中任何一个组件都可能会触发页面的弹窗，为了组件的复用会将弹窗进行一定程度的封装。

和 case1 不一样的地方是，case1 更多的是组件的拆分/封装所带来的逻辑层代码的影响，和视图层的关系不大。而在 case2 当中，组件拆分/封装不仅带来了逻辑层代码通讯的影响，同时对于视图层的渲染也带来的一定的挑战。


这种场景所要解决的核心问题：

* 弹窗自身相关；
  * 展示/关闭逻辑；
  * 视图渲染；
* 弹窗和其他模块/组件之间的逻辑交互；

目前的处理方式：

1. BasePopup 不杂糅业务逻辑；暴露接口让外部可控制展示；关闭时抛出关闭事件以及业务 Popup 组件 Key；
2. BasePopup 提供 slot 插槽用以业务 Popup 组件拓展；
3. 业务 Popup 抛出事件，统一收敛至 Page 页面进行处理；

各组件实际是要和业务 Popup 交互，统一收口到了不是那么强关联的 Page 进行处理：

* 组件之间通讯依赖路径长；
* Popup 管理松散；
* 原本应该属于 Popup 内部处理的逻辑强耦合至 Page，需要做各种 Popup type 的判断做分支逻辑处理；

那么针对此种情况依赖引入 StateManager 进行管理。和 case1 的 StateManager 不一样的地方是和视图层有了联系，这里其实可以非常自然的联想到使用 Store 来实现 StateManager。还是利用 mvvm 的思想，Store 当中的数据为响应式数据，可以驱动视图依赖进行渲染更新。

这里需要明确的一个点就是：Store 适用的场景非常宽泛。并不是说只有全局数据才能放到 Store 里面，任何依赖路径过长的通讯场景、多组件状态共享都可以使用。

```javascript
// popupStateManager.js
import { createStore } from '@mpxjs/core'

let eventHandler = null
const noop = () => {}
export const popupStateManager = createStore({
  state: {
    type: '',
    visible: false,
    data: {}
  },
  mutations: {
    showPopup(store, payload) {
      Object.assign(store.state, payload, { visible: true })
      eventHandler = payload.eventHandler || noop
    },
    hidePopup(({ state })) {
      state.visible = false
    }
  },
  actions: {
    handleEvent() {
      eventHandler()
    }
  }
})
```

```javascript
<template>
  <component visible="{{ visible }}" data="{{ data }}" bindevent="handlePopupEvent"></component>
</template>

<script>
import { createComponent } from '@mpxjs/core'
import popupStateManager from 'popupStateManager'

createComponent({
  computed: {
    ...popupStateManager.state(['visible', 'data'])
  },
  methods: {
    handlePopupEvent() {
      this.handleEvent()
    },
    ...popupStateManager.action(['handleEvent'])
  }
})
</script>
```

* 组件之间的通讯依赖路径为1；
* 将原本耦合至 Page 当中的逻辑拆解到各自的业务 Popup 当中自行去处理，Page 代码量大幅减少；
* StateManager 统一管理 Popup 的展示/关闭逻辑；

对于这一整个页面来说，页面的状态和行为决定了整个页面的渲染（对于 Vue 来说没有页面的概念，只有 Component，一个页面其实就是 Root Component）。对于这个页面所包含的任何一个组件来说同样也适用：组件自身的状态和行为决定了这个组件渲染。

todo：补一个图

组件依赖关系：多对一
通讯层数 >= 2


### 数据流向、事件交互

对于页面/组件的通讯遵循：

1. 单向数据流，数据流向清晰，易观测；（双向数据绑定）

2. 事件交互 >= 2层才能触达的场景就需要去思考是否需要做抽象；


### 组件的拆分和复用

组件的拆分和复用不是同一个概念。拆分不一定会被复用，核心的目的也不一定是为了复用（例如一个单文件超过了500行的代码，可以考虑将部分代码做拆分，使得代码的结构更加清晰，阅读起来心智负担更小），而被复用的组件一般是经过一定设计和抽象之后做的拆分。

这也是做业务组件和基础组件（Button、Dialog 等）开发非常不一样的地方，基础组件更注重复用性，可拓展性。

一般是单页，页面上承载了不同的元素。

在项目开发初期阶段，大家可能关注的点更多在于视图层所体现出的结构（设计稿），缺少对于数据模型的关注（可能后端接口还没ready，前端同学最好是作为设计方站在整个产品视角去梳理用户交互、状态扭转关键路径，得出数据模型）。（侧ToC偏营销场景的项目）

* 组件的结构（方便组件的拆解，大文件 -> 小文件）
* 组件的状态（组件是否需要维护状态）
* 组件的功能

无状态，纯渲染组件相对来说容易，明确的至上而下的数据流向，响应式数据发生变化会触发这些组件重新渲染更新；

有状态的组件，初始化

* 数据变更直接影响视图
* 数据变更 -> 逻辑处理 -> 再影响视图

* API 调用：$refs，命令式的
视图和逻辑层没有完全解耦（小程序的场景 -> $refs 的使用）
* 通过响应式数据来控制，mvvm 形式，数据驱动

组件拆分的层数
数据通讯的类型

收敛至顶层处理还是发散到组件内部去处理？


多层嵌套、属性透传问题（>= 2层）-> 充分利用 mvvm 的思想，数据驱动视图。
事件通讯（props + events）

事件通讯超过2层 -> 这个行为核心需要解决的问题？


todo：弹窗组件

1. 状态管理、数据扭转

是否为响应式

* 全局状态管理
* 页面状态
* 组件状态

是否使用了团队之前未使用到的技术；
技术评审要达到的效果是能够让没做过这个需求的人，看完技术方案，可以很快的明白技术架构；
评价技术方案怎么样，需要看团队新人看到这个技术方案之后，能多快接手这个功能；
多画图少文字；（看写的文字还不如看代码）
代码的复杂度和代码的长度没必然关系
