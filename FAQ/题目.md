[面试题](https://mp.weixin.qq.com/s/J9uQmFLOGE6A4JpgDSXdJg)

1. 设计一个异步任务类

```javascript
class Task {
  constructor() {
    this.curIndex = 0
    this.paused = false
    this.taskQueue = []
  }

  add(fn, context, ...args) {
    this.taskQueue.push((next) => {
      if (this.paused) {
        return
      }
      fn.apply(context, [next, ...args])
    })
    
    return this
  }

  run() {
    const task = this.taskQueue[this.curIndex++]
    task && task(this.run.bind(this))
  }

  stop() {
    this.paused = true
  }
}

function task1(next) {
  setTimeout(() => {
    console.log('red')
    next()
  }, 3000)
}

function task2(next, b) {
  setTimeout(() => {
    console.log('green')
    next()
  }, 1000)
}

function task3(next, c) {
  setTimeout(() => {
    console.log('yellow')
    next()
  }, 2000)
}

let task = new Task()
task.add(task1).add(task2, null, 3).add(task3)
task.run()
```

使用 promise 来实现：

```javascript
function task1() {
  console.log('yellow')
}
function task2() {
  console.log('green')
}
function task3() {
  console.log('red')
}
```


**思考：callback 和 promise 的对比**

使用 callback 形式去组织代码的情况下，一旦流程复杂起来，涉及到多异步操作的情况下，就会出现 callback 嵌套 callback 的情况，也就是回调地狱。当然了，**callback 的使用也分具体场景，比如同步的 callback 和 异步的 callback**，异步的 callback 是在定时器到时间后，将 callback 推到 event queue当中，这个时候 stack 上的栈信息已经没有了，当异步的 callback 在执行的时候只会保留其自身的执行栈。这样在错误排查的时候并不能追踪到这个异步 callback 执行的上下文。此外，`try/watch`也不适用于异步的 callback。

另外一个问题就是 callback 和 promise 在执行过程回调函数的控制权。使用 callback 是将函数调用的控制权交给了宿主函数，而 promise 方法的回调函数调用的控制权是由自身去控制的，使用 callback 有可能会出现宿主函数内部程序出错，导致 callback 不执行/执行多次等等情况，从代码执行安全的角度来说的话，使用 promise 更能保证代码执行的正确。另外还有一个问题就是代码执行的时序，promise 统一为异步执行，保证了代码执行的顺序。

2. 模拟实现 promisify 方法

```javascript
function promisify(fn) {
  if (fn instanceof Promise) {
    return fn
  }
  return function(...args) {
    return new Promise((resolve, reject) => {
      fn.apply(null, [...args, (err, data) => {
        if (err) reject(err)
        resolve(data)
      }])
    })
  }
}
```

3. 模拟实现 Promise.finally 方法

版本一：

```javascript
Promise.prototype.finally = function(fn) {
  return new Promise((resolve, reject) => {
    Promise.resolve().then(fn).then(resolve, reject)
  })
}
```

**版本一：这个版本实现的有缺陷，在 finally 返回了一个全新的 promise 实例，这个 promise 实例和原有的调用 finally 实例脱离了数据层面的联系，导致在 finally 函数后面再跟 then 方法的时候无法进行传值**

```javascript
// 原生的 Promise 实现会打印 3
Promise.resolve(3).finally(() => {}).then(val => console.log(val))
```

所以为了解决这个问题，需要 finally 返回的 promise 不能为一个全新的 promise，而是之前调用 then 方法的 promise 实例。这样就能获取到前面的 promise 实例传递过来的值。此外在 then 方法内部也需要返回一个 promise，且 resolve 的值为上一个 promise 传递过来的，这样就可以完成在 finally 后面继续接 then 方法。

```javascript
Promise.prototype.finally = function (fn) {
  return this.then(val => Promise.resolve(fn()).then(() => val))
}
```

4. 模拟实现 Promise.race 方法
