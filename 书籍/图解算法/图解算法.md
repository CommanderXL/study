## Chapter - 2.3 选择排序

选择排序的核心思想是：一一找出数据(n个)当中最大(小)的数值，然后进行排序。

不过需要注意的是操作数量的减少。第一次为 n，第二次为 n - 1...直到最后一次为1。

那么对应的时间复杂度为：O(n * 1/2 * n)

从实际的代码实现角度来说，也是这个对应的时间复杂度（2次 for 循环）。


## Chapter - 3 递归

核心点：

1. 找出基线条件，这个条件需要尽可能的简单
2. 找出递归条件

```javascript
function recursive () {
  if (true) {
    // 进行递归
  } else {
    // 进入基线条件并返回
  }
}
```

递归的执行和**栈**数据结构有非常重要的联系。每个函数的调用都会压入栈，栈里面保存了当前函数里面可以访问的数据，调用栈过长的话会占用大量的内存。

从另外一个角度来说，栈的长度也代表了代码执行的次数。栈越长，递归调用的次数也就越多，那么对应的时间复杂度也会随着增加。

## Chapter - 4 分治

* 均分土地（1680 x 640），获取最大土地块的长度。

* 二分查找（时间复杂度为O(logN)）：

首先对于原数据列表进行排序(例如升序)。

基线条件：满足条件的值
递归的条件：取中间值，如果大于给定的值，取中间值左侧的值进行递归处理。如果小于给定的值，取中间值右侧的值进行递归处理。

再谈大O表示法

* 快速排序的时间复杂度为什么是：O(n * logn) --> 单次的时间复杂度 * 执行的次数