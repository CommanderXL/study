* [官方文档](https://webpack.js.org/configuration/cache/)
* [changelog-v5](https://github.com/webpack/changelog-v5/blob/master/guides/persistent-caching.md)


a. 独立入口 module(EntryDependency)
b. 依赖 module

一个 module 的处理流程会经由以下几个阶段：

1. [Work Queues](https://webpack.js.org/blog/2020-10-10-webpack-5-release/#work-queues)

compilation 维护了几个不同的 `AsyncQueue`(从一个 request -> module 创建 -> 编译 -> 依赖收集 -> 依赖处理全流程的封装)，对于一个 module 来说都会经由这几个 `AsyncQueue` 

对于 `AsyncQueue` 来说内部是有缓存机制的，不过从目前的几个 `asyncQueue` 实例来看的话，目前仅有 `addModule` 这个异步队列具备缓存的能力。

```javascript
new AsyncQueue {
  ...
  add (item, callback) {
    ...
    this.hooks.beforeAdd.callAsync(item, err => {
      const key = this._getKey(item);
      const entry = this._entries.get(key);
      if (entry !== undefined) {
         if (entry.state === DONE_STATE) {
         if (inHandleResult++ > 3) {
            process.nextTick(() => callback(entry.error, entry.result));
         } else {
            callback(entry.error, entry.result);
         }
         inHandleResult--;
         } else if (entry.callbacks === undefined) {
            entry.callbacks = [callback];
         } else {
            entry.callbacks.push(callback);
         }
         return;
      }
    })
  }
}
```

```javascript
// 处理 module dependency
Compilation.prototype.processDependenciesQueue

// module 和 compilation，缓存系统建立起关系，
Compilation.prototype.addModuleQueue

// 创建 module 的阶段：根据 module request 的类型，借由 moduleFactory 工厂初始化为一个 module
this.factorizeQueue = new AsyncQueue({
  name: 'factorize',
  parent: this.addModuleQueue,
  processor: this._factorizeModule.bind(this)
})

Compilation.prototype.factorizeQueue = function (options, callback) {
  this.factorizeQueue.add(options, callback)
}

// 对模块开始编译处理，编译过程中通过 parser 来收集对应的依赖 Dependency
this.buildQueue = new AsyncQueue({
  name: 'build',
  parent: this.factorizeQueue,
  processor: this._buildModule.bind(this)
})

Compilation.prototype.buildQueue = function (module, callback) {
  this.buildQueue.add(module, callback)
}
```

`_addModule` 缓存：从缓存当中获取 `module` 相关的信息，这也是相较于 v4 版本在流程上比较大的一个变化？，在对于模块处理之前从缓存当中获取。

```javascript
// compilation.js
this._moduleCache = this.getCache('Compilation/modules')

_addModule (module, callback) {
  const identifier = module.identifier()
  ...
  // 获取缓存
  this._moduleCache.getCache(identifier, null, (err, cacheModule) => {
    ...
  })
}
```

`_buildModule` 缓存：`module` 经由 loader 处理过程当中 loaderContext 上暴露了 `cacheable` api 用来控制这个 module 是否需要重新走一遍 loader 处理及 parse 的流程。

```javascript
// compilation.js
_buildModule (module, callback) {
  ...
  module.needBuild(
    {
      compilation: this,
      fileSystemInfo: this.fileSystemInfo,
      valueCacheVersions: this.valueCacheVersions
    },
    (err, needBuild) => {
      if (!needBuild) {
        if (currentProfile !== undefined) {
          currentProfile.markBuildingEnd()
        }
        this.hooks.stillValidModule.call(module)
        return callback()
      }

      this.hooks.buildModule.call(module)
      this.builtModules.add(module)
      module.build(..., () => {
        ...
        // 模块编译构建完成后缓存模块，但是在 compiler 执行的过程当中，这部分的任务是被缓存到一个队列里面：pendingIdleTasks，compiler 空闲阶段才会执行这些异步任务
        this._modulesCache.store(module.identifier(), null, module, err => {
          ...
          this.hooks.succeedModule.call(module)
          return callback()
        })
     })
    }
  )
}

// NormalModule.js
needBuild(context, callback) {
  // build if enforced
  if (this._forceBuild) return callback(null, true)

  // always build when module is not cacheable
  if (!this.buildInfo.cacheable) return callback(null, true)

  // build when there is no snapshot to check
  if (!this.buildInfo.snapshot) return callback(null, true)

  // build when valueDependencies have changed
  ...
}


// IdleFileCachePlugin.js
const pendingIdleTasks = new Map()

compiler.cache.hooks.store.tap({
  name: 'IdleFileCachePlugin',
  state: Cache.STAGE_DISK
}, (identifier, etag, data) => {
  // 缓存相关的存储内容
  pendingIdleTasks.set(identifier, () => {
    strategy.store(identifier, etag, data)
  })
})

compiler.cache.hooks.shutdown.tapPromise({
  name: 'IdleFileCachePlugin',
  state: Cache.STAGE_DISK
}, () => {
  ...
  const jobs = Array.from(pendingIdleTasks.values())
  const promises = jobs.map(fn => fn())
  pendingIdleTasks.clear()
  promises.push(currentIdlePromise)
  const promise = Promise.all(promises)
  // 所有的 pendingIdleTasks 执行完后开始做存储相关的工作
  currentIdlePromise = promise.then(() => strategy.afterAllStored())
})
```

和缓存有关的几个内部插件：

// type: 'fileSystem'

* IdleFileCachePlugin
* PackFileCacheStrategy.js

// type: 'memory'

* MemoryWithGcCachePlugin
* MemoryCachePlugin

`compilation.fileSystemInfo.createSnapshot`

```javascript
// fileDependencies 文件依赖，对于一些构建出来的虚拟模块，需要注意其对应的依赖路径
this.watch(
  compilation.fileDependencies,
  compilation.contextDependencies,
  compilation.missingDependencies
)
```

2. 持久化缓存

webpack5 规范了持久化缓存的接口定义，在内置的 module/dependency 上都部署了持久化缓存的接口，例如 `EntryDependency` 入口依赖：

```javascript
// EntryDependency.js
class EntryDependency extends ModuleDependency {
  constructor(request) {
    super(request)
  }

  get type() {
    return 'entry'
  }

  get category() {
    return 'esm'
  }
}

// 调用 makeSerializeable 方法完成这个依赖的序列化接口注册，同时这个依赖上还完成了对于序列化接口的定义
makeSerializeable(EntryDependency, 'webpack/lib/dependencies/EntryDependency')

module.exports = EntryDependency

// ModuleDependency.js
class ModuleDependency extends Dependency {
  ...
  serialize(context) {
    const { write } = context
    write(this.request)
    write(this.userRequest)
    write(this.range)
    super.serialize(context)
  }

  deserialize(context) {
    const { read } = context
    this.request = read()
    this.userRequest = read()
    this.range = read()
    super.deserialize(context)
  }
}
```

一些中间态数据走持久化缓存