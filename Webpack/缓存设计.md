* [官方文档](https://webpack.js.org/configuration/cache/)
* [changelog-v5](https://github.com/webpack/changelog-v5/blob/master/guides/persistent-caching.md)


a. 独立入口 module(EntryDependency)
b. 依赖 module

一个 module 的处理流程会经由以下几个阶段：

1. [Work Queues](https://webpack.js.org/blog/2020-10-10-webpack-5-release/#work-queues)

compilation 维护了几个不同的 `AsyncQueue`(从一个 request -> module 创建 -> 编译 -> 依赖收集 -> 依赖处理全流程的封装)，对于一个 module 来说都会经由这几个 `AsyncQueue` 

对于 `AsyncQueue` 来说内部是有缓存机制的，不过从目前的几个 `asyncQueue` 实例来看的话，目前仅有 `addModule` 这个异步队列具备缓存的能力。

```javascript
new AsyncQueue {
  ...
  add (item, callback) {
    ...
    this.hooks.beforeAdd.callAsync(item, err => {
      const key = this._getKey(item);
      const entry = this._entries.get(key);
      if (entry !== undefined) {
         if (entry.state === DONE_STATE) {
         if (inHandleResult++ > 3) {
            process.nextTick(() => callback(entry.error, entry.result));
         } else {
            callback(entry.error, entry.result);
         }
         inHandleResult--;
         } else if (entry.callbacks === undefined) {
            entry.callbacks = [callback];
         } else {
            entry.callbacks.push(callback);
         }
         return;
      }
    })
  }
}
```

```javascript
// 处理 module dependency
Compilation.prototype.processDependenciesQueue

// module 和 compilation，缓存系统建立起关系，
Compilation.prototype.addModuleQueue

// 创建 module 的阶段：根据 module request 的类型，借由 moduleFactory 工厂初始化为一个 module
this.factorizeQueue = new AsyncQueue({
  name: 'factorize',
  parent: this.addModuleQueue,
  processor: this._factorizeModule.bind(this)
})

Compilation.prototype.factorizeQueue = function (options, callback) {
  this.factorizeQueue.add(options, callback)
}

// 对模块开始编译处理，编译过程中通过 parser 来收集对应的依赖 Dependency
this.buildQueue = new AsyncQueue({
  name: 'build',
  parent: this.factorizeQueue,
  processor: this._buildModule.bind(this)
})

Compilation.prototype.buildQueue = function (module, callback) {
  this.buildQueue.add(module, callback)
}
```

`_addModule` 缓存：

```javascript

this._moduleCache = this.getCache('Compilation/modules')

_addModule (module, callback) {
  const identifier = module.identifier()
  ...
  // 获取缓存
  this._moduleCache.getCache(identifier, null, (err, cacheModule) => {
    ...
  })
}
```

`_buildModule` 缓存：

```javascript
// compilation.js
_buildModule (module, callback) {
  ...
  module.build(..., () => {
    ...
    // 缓存模块，但是在 compiler 执行的过程当中，这部分的任务是被缓存到一个队列里面：pendingIdleTasks，compiler 空闲阶段才会执行这些异步任务
    this._modulesCache.store(module.identifier(), null, module, err => {
      ...
      this.hooks.succeedModule.call(module)
      return callback()
    })
  })
}


// IdleFileCachePlugin.js
const pendingIdleTasks = new Map()

compiler.cache.hooks.store.tap({
  name: 'IdleFileCachePlugin',
  state: Cache.STAGE_DISK
}, (identifier, etag, data) => {
  // 缓存相关的存储内容
  pendingIdleTasks.set(identifier, () => {
    strategy.store(identifier, etag, data)
  })
})

compiler.cache.hooks.shutdown.tapPromise({
  name: 'IdleFileCachePlugin',
  state: Cache.STAGE_DISK
}, () => {
  ...
  const jobs = Array.from(pendingIdleTasks.values())
  const promises = jobs.map(fn => fn())
  pendingIdleTasks.clear()
  promises.push(currentIdlePromise)
  const promise = Promise.all(promises)
  // 所有的 pendingIdleTasks 执行完后开始做存储相关的工作
  currentIdlePromise = promise.then(() => strategy.afterAllStored())
})
```

和缓存有关的几个内部插件：

// type: 'fileSystem'

* IdleFileCachePlugin
* PackFileCacheStrategy.js

// type: 'memory'

* MemoryWithGcCachePlugin
* MemoryCachePlugin

`compilation.fileSystemInfo.createSnapshot`


2. module.build 缓存设计

```javascript
// fileDependencies 文件依赖，对于一些构建出来的虚拟模块，需要注意其对应的依赖路径
this.watch(
  compilation.fileDependencies,
  compilation.contextDependencies,
  compilation.missingDependencies
)
```

3. Dependency 缓存依赖

首先了解下序列化


4. 持久化缓存

一些中间态数据的缓存