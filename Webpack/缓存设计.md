* [官方文档](https://webpack.js.org/configuration/cache/)
* [changelog-v5](https://github.com/webpack/changelog-v5/blob/master/guides/persistent-caching.md)


1. 持久化缓存是什么？所要解决的问题是什么？之前针对这些问题有哪些解决方案？

之前对于 `cache-loader` 也有一定的研究。但是 `cache-loader` 也仅仅能覆盖到经由 `loader` 处理后的文件内容，缓存内容的范围比较受限。另外就是 `cache-loader` 是通过对比文件 metadata 的 timestamps，这种缓存失效策略不是非常的安全，具体见 case。

此外还有 `babel-loader`、`eslint-loader` 内置的缓存功能。核心的目的就是已经处理过的内容不需要再重新走一遍原有的流程。

2. 持久化缓存如何使用？使用过程当中需要注意的点？

首先，持久化缓存是开箱即用的一个功能，默认不开启。基本的 [`cache`](https://webpack.js.org/configuration/cache/#cache) 使用：

```javascript
// webpack.config.js
module.exports = {
  cache: {
    type: 'fileSystem',
    buildDependencies: {
      config: [__filename]
    }
  }
}
```

在 `cache` 字段下完成有关持久化缓存的基本配置，当 type 为 fileSystem 时开启持久化缓存的能力，另外需要特别注意的是 `buildDependencies` 的配置，这个配置和整个构建流程的安全性有关。常见于和项目相关的一些配置信息，例如你是使用 `@vue/cli` 进行开发的项目，那么 `vue.config.js` 就需要作为项目的 `buildDependencies`，此外 webpack 在内部处理流程当中将所有的 loader 也作为了 `buildDependenceis`，一旦 `buildDependencies` 发生了变更，那么在编译流程的启动阶段便会导致整个缓存失效。

todo: 几个核心的配置选项是：...

此外，和持久化缓存另外一个相关的配置是：[`snapshot`](https://webpack.js.org/configuration/other-options/#snapshot)。`snapshot` 相关的配置决定了 `module` 在 `resolve`、`compile` 结束后创建 `snapshot` 时所采用的策略。这个策略最终会影响到缓存是否失效。

```javascript
module.exports = {
  snapshot: {
    managedPaths: []
  }
}
```

构建产出缓存在 webpack 内部已经完成了，但是对于一个应用项目而言，高频的业务开发迭代节奏，基础库的升级、第三方库的接入等等，对于这部分的更新而言 webpack 显然需要做的一件事情就是感知其变更，同时使缓存失效而重新构建新的模块，构建结束后重新写入缓存，这也是 webpack 在持久化缓存设计当中非常重要的一个特性：安全性。

3. 相关的概览的介绍，原理分析&工作流

在开启了持久化缓存策略后，是 `fileSystem` 和 `memory` 分级缓存配合工作的。

`module` 的定义是什么？

`module` 被创建之前，需要经过一系列的 resolve 过程，例如需要被处理的文件路径，loader 等等。

`module` 被创建之后，需要经过 build 的过程：基本上就是交由 loader 处理后进行 parse，这个过程结束后开始处理依赖。

首先我们来看下一个 `module` 的处理流程，一般会经过：

* `resolve`（路径查找，需要被处理的文件路径，loader 路径等）
* `build`（构建）
* `generate`（代码生成）

等阶段，特别是针对 `resolve`、`build` 阶段都有一些优化的建议或者是相关的插件来提升其效率。例如在 `resolve` 阶段可以 。。。其核心的目的还是为了减少 `resolve` 的流程来提高效率，。在 `build` 阶段，针对一些耗时的操作使用 `cache-loader` 缓存对应的处理结果等等。

那么在持久化缓存的方案当中，针对这些场景又是如何来进行设计和处理的呢？

首先来看下和 `resolve` 相关的持久化缓存插件：`ResolverCachePlugin.js`

```javascript
class CacheEntry {
  constructor(result, snapshot) {
    this.result = result
    this.snapshot = snapshot
  }
  serialize({ write }) {
    write(this.result)
    write(this.snapshot)
  }
  deserialize({ read }) {
    this.result = read()
    this.snapshot = read()
  }
}

makeSerializable(CacheEntry, 'webpack/lib/cache/ResolverCachePlugin')

class ResolverCachePlugin {
  apply(compiler) {
    const cache = compiler.getCache('ResolverCachePlugin')
    let fileSystemInfo
    let snapshotOptions
    ...
    compiler.hooks.thisCompilation.tap('ResolverCachePlugin', compilation => {
      // 创建 resolve snapshot 相关的配置
      snapshotOptions = compilation.options.snapshot.resolve
      fileSystemInfo = compilation.fileSystemInfo
      ...
    })

    const doRealResolve = (
      itemCache,
      resolver,
      resolveContext,
      request,
      callback
    ) => {
      ...
      resolver.doResolve(
        resolver.hooks.resolve,
        newRequest,
        'Cache miss',
        newResolveContext,
        (err, result) => {
          const fileDependencies = newResolveContext.fileDependencies
          const contextDependencies = newResolveContext.contextDependencies
          const missingDependencies = newResolveContext.missingDependencies
          // 创建快照
          fileSystemInfo.createSnapshot(
            resolveTime,
            fileDependencies,
            contextDependencies,
            missingDependencies,
            snapshotOptions,
            (err, snapshot) => {
              ...
              // 持久化缓存
              itemCache.store(new CacheEntry(result, snapshot), storeErr => {
                ...
                callback()
              })
            }
          )
        }
      )
    }

    compiler.resolverFactory.hooks.resolver.intercept({
      factory(type, hook) {
        hook.tap('ResolverCachePlugin', (resolver, options, userOptions) => {
          ...
          resolver.hooks.resolve.tapAsync({
            name: 'ResolverCachePlugin',
            stage: -100
          }, (request, resolveContext, callback) => {
            ...
            const itemCache = cache.getItemCache(identifier, null)
            ...
            const processCacheResult = (err, cacheEntry) => {
              if (cacheEntry) {
                const { snapshot, result } = cacheEntry
                // 判断快照是否失效
                fileSystemInfo.checkSnapshotValid(
                  snapshot,
                  (err, valid) => {
                    if (err || !valid) {
                      // 进入后续的 resolve 环节
                      return doRealResolve(
                        itemCache,
                        resolver,
                        resolveContext,
                        request,
                        done
                      )
                    }
                    ...
                    // 使用缓存数据
                    done(null, result)
                  }
                )
              }
            }
            // 获取缓存
            itemCache.get(processCacheResult)
          })
        })
      }
    })
  }
}
```

webpack 在做 resolve 缓存的流程是非常清晰的：通过在 `resolverFactory.hooks.resolver` 上做了劫持，并添加 `resolver.hooks.resolve` 的钩子，需要注意的是这个 resolve hook 的执行时机 `stage: -100`，这也意味着这个 hook 执行时机是非常靠前的。

通过 identifier 唯一标识去获取持久化缓存的内容：resolveData 和 snapshot，接下来判断 snapshot 是否失效，如果失效的话就重新走 resolve 的逻辑，如果没有失效直接返回 resolveData，跳过 resolve 流程。而在实际走 resolve 的过程当中，流程结束后，首先需要做的一个工作就是依据 `fileDependencies`、`contextDependencies`、`missingDependencies` 以及在 webpack.config 里面 snapshot 的 resolve 配置来生成快照的内容，到这里 resolve 的结果以及 snapshot 都已经生成好了，接下来调用持久化缓存的接口 `itemCache.store` 将这个缓存动作放到缓存队列当中。

接下来看下 module build 当中和持久化缓存相关的内容。

在一个 module 在创建完后，需要将这个 module 加入到整个 moduleGraph 当中来，首先通过 `_modulesCache.get(identifier)` 来获取这个 module 的缓存数据，如果有缓存数据那么使用缓存数据，没有的话就使用本次创建 module 当中使用的数据。

```javascript
class Compilation {
  ...
  handleModuleCreation(
    {
      factory,
      dependencies,
      originModule,
      contextInfo,
      context,
      recusive = true,
      connectOrigin = recursive
    },
    callback
  ) {
    // 创建 module
    this.factorizeModule({}, (err, factoryResult) => {
      ...
      const newModule = factoryResult.module

      this.addModule(newModule, (err, module) => {
        ...
      })
    })
  }

  _addModule(module, callback) {
    const identifer = module.identifier()
    // 获取缓存模块
    this._modulesCache.get(identifier, null, (err, cacheModule) => {
      ...
      this._modules.set(identifier, module)
      this.modules.add(module)
      ...
      callback(null, module)
    })
  }
}
```

接下来进入到 buildModule 阶段，在实际进入后续 build 流程之前，有个比较重要的工作就是通过 `module.build` 方法判断当前 module 是否需要重新走 build 流程，这里面也有几层不同的判断逻辑，例如 loader 处理过程中指定 `buildInfo.cachable`，又或者说当前模块没有 snapshot 去检查也是需要重新走 build 流程的，最后就是在 snapshot 存在的情况下，需要检查 snapshot 是否失效。一旦判断这个 module 的 snapshot 没有失效，即走缓存的逻辑，那么最终会跳过这个 module 被 loader 处理以及被 parse 的环节。因为这个 module 的所有进行都是从缓存当中获取，包括这个 module 的所有依赖，接下来就进入递归处理依赖的阶段。如果 snapshot 失效了，那么就走正常的 build 流程(loader 处理，parse，收集依赖等)，build 流程结束后，会利用在构建过程中收集到的 `fileDependencies`、`contextDependencies`、`missingDependencies` 以及在 webpack.config 里面 snapshot 的 module 配置来生成快照的内容，此时当前 module 编译流程结束，同时快照也已经生成好了，接下来才会调用持久化缓存接口 `this._modulesCache.store(module.identifier(), null, module)` 将这个缓存动作放到缓存队列当中。

```javascript
// compilation.js
class Compilation {
  ...
  _buildModule(module, callback) {
    ...
    // 判断 module 是否需要被 build
    module.needBuild(..., (err, needBuild) => {
        ...
        if (!needBuild) {
          this.hooks.stillValidModule.call(module)
          return callback()
        }

        ...
        // 实际 build 环节
        module.build(..., err => {
          ...
          // 将当前 module 内容加入到缓存队列当中
          this._modulesCache.store(module.identifier(), null, module, err => {
            ...
            this.hooks.succeedModule.call(module)
            return callback()
          })
        })
      }
    )
  }
}

// NormalModule.js
class NormalModule extends Module {
  ...
  needBuild(context, callback) {
    if (this._forceBuild) return callback(null, true)

    // always build when module is not cacheable
    if (!this.buildInfo.cachable) return callback(null, true)

    // build when there is no snapshot to check
    if (!this.buildInfo.snapshot) return callback(nuull, true)
    ...

    // check snapshot for validity
		fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, (err, valid) => {
			if (err) return callback(err);
			if (!valid) return callback(null, true);
			const hooks = NormalModule.getCompilationHooks(compilation);
			hooks.needBuild.callAsync(this, context, (err, needBuild) => {
				if (err) {
					return callback(
						HookWebpackError.makeWebpackError(
							err,
							"NormalModule.getCompilationHooks().needBuild"
						)
					);
				}
				callback(null, !!needBuild);
			});
		});
  }
}
```

通过分析 module 被创建之前的 resolve 流程以及创建之后的 build 流程，基本了解了在整个缓存系统当中上层使用的流程，一个比较重要的点就是缓存的安全性设计，**即在做持久化缓存的过程中，需要被缓存的内容是一方面，有关这个缓存的 snapshot 也是需要被缓存下来的，这个是缓存是否失效的判断依据**。

那么对于 snapshot 来说，有哪些内容是需要被关注的呢？

首先第一点就是和当前需要被缓存内容强相关的路径依赖，包含了：`fileDependencies`、`contextDependencies`、`missingDependencies`，在生成 snapshot 的过程当中，这些路径依赖是需要被包含在内的，同时也是判断缓存是否失效的依据；

第二点就是在 snapshot 相关的配置策略，这也决定了 snapshot 的生成方式（timestampes、content hash）、速度以及可靠性。

这部分有关 snapshot 具体的生成策略可以参照 [`FileSystemInfo.js`](https://github.com/webpack/webpack/blob/main/lib/FileSystemInfo.js) 里面有关 `createSnapshot` 方法的实现。

此外还想说下就是整个持久化缓存的底层设计：持久化缓存的流程设计是非常独立且和项目应用的 compile 流程是完全解耦的。

在这其中有一个非常重要的类 `Cache`，衔接了整个项目应用的 compile 流程以及持久化缓存的流程，compile 流程当中需要进行缓存的读取或者写入操作的时候直接调用 `Cache` 实例上暴露的 `get`、`store` 方法，然后 `Cache` 通过自身暴露出来的 `hooks.get`、`hooks.store` 来和缓存系统进行交互。之前有提到过在使用持久化缓存的过程中 webpack 内部其实是启动了分级缓存，即：内存缓存(`MemoryCachePlugin.js`、`MemoryWithGcCachePlugin.js`)和文件缓存(`IdleFileCachePlugin.js`)。

内存缓存和文件缓存分别注册 `Cache` 上暴露出来的 `hooks.get`、`hooks.store`，这样当在 compile 过程当中抛出 `get`/`store` 事件时也就和缓存的流程衔接上了。

在 `get` 的阶段， watch 模式下的持续构建环节，优先使用内存缓存（一个 Map 数据）。在二次构建，没有内存缓存的情况下，使用文件缓存。

在 `store` 的阶段，并非是立即将缓存内容写入磁盘，而是将所有的写操作缓存到一个队列里面，当 compile 阶段结束后，在进行写的操作。

```javascript
// lib/Cache.js
class Cache {

}
```

todo: 

1. missingDependency 如何去理解？

a. 独立入口 module(EntryDependency)
b. 依赖 module

一个 module 的处理流程会经由以下几个阶段：

1. [Work Queues](https://webpack.js.org/blog/2020-10-10-webpack-5-release/#work-queues)

compilation 维护了几个不同的 `AsyncQueue`(从一个 request -> module 创建 -> 编译 -> 依赖收集 -> 依赖处理全流程的封装)，对于一个 module 来说都会经由这几个 `AsyncQueue` 

对于 `AsyncQueue` 来说内部是有缓存机制的，不过从目前的几个 `asyncQueue` 实例来看的话，目前仅有 `addModule` 这个异步队列具备缓存的能力。

```javascript
new AsyncQueue {
  ...
  add (item, callback) {
    ...
    this.hooks.beforeAdd.callAsync(item, err => {
      const key = this._getKey(item);
      const entry = this._entries.get(key);
      if (entry !== undefined) {
         if (entry.state === DONE_STATE) {
         if (inHandleResult++ > 3) {
            process.nextTick(() => callback(entry.error, entry.result));
         } else {
            callback(entry.error, entry.result);
         }
         inHandleResult--;
         } else if (entry.callbacks === undefined) {
            entry.callbacks = [callback];
         } else {
            entry.callbacks.push(callback);
         }
         return;
      }
    })
  }
}
```

```javascript
// 处理 module dependency
Compilation.prototype.processDependenciesQueue

// module 和 compilation，缓存系统建立起关系，
Compilation.prototype.addModuleQueue

// 创建 module 的阶段：根据 module request 的类型，借由 moduleFactory 工厂初始化为一个 module
this.factorizeQueue = new AsyncQueue({
  name: 'factorize',
  parent: this.addModuleQueue,
  processor: this._factorizeModule.bind(this)
})

Compilation.prototype.factorizeQueue = function (options, callback) {
  this.factorizeQueue.add(options, callback)
}

// 对模块开始编译处理，编译过程中通过 parser 来收集对应的依赖 Dependency
this.buildQueue = new AsyncQueue({
  name: 'build',
  parent: this.factorizeQueue,
  processor: this._buildModule.bind(this)
})

Compilation.prototype.buildQueue = function (module, callback) {
  this.buildQueue.add(module, callback)
}
```

`_addModule` 缓存：从缓存当中获取 `module` 相关的信息，在对于模块处理之前从缓存当中获取。

```javascript
// compilation.js
this._moduleCache = this.getCache('Compilation/modules')

_addModule (module, callback) {
  const identifier = module.identifier()
  ...
  // 获取缓存
  this._moduleCache.getCache(identifier, null, (err, cacheModule) => {
    ...
  })
}
```

`_buildModule` 缓存：`module` 经由 loader 处理过程当中 loaderContext 上暴露了 `cacheable` api 用来控制这个 module 是否需要重新走一遍 loader 处理及 parse 的流程。

```javascript
// compilation.js
_buildModule (module, callback) {
  ...
  module.needBuild(
    {
      compilation: this,
      fileSystemInfo: this.fileSystemInfo,
      valueCacheVersions: this.valueCacheVersions
    },
    (err, needBuild) => {
      if (!needBuild) {
        if (currentProfile !== undefined) {
          currentProfile.markBuildingEnd()
        }
        this.hooks.stillValidModule.call(module)
        return callback()
      }

      this.hooks.buildModule.call(module)
      this.builtModules.add(module)
      module.build(..., () => {
        ...
        // 模块编译构建完成后缓存模块，但是在 compiler 执行的过程当中，这部分的任务是被缓存到一个队列里面：pendingIdleTasks，compiler 空闲阶段才会执行这些异步任务
        this._modulesCache.store(module.identifier(), null, module, err => {
          ...
          this.hooks.succeedModule.call(module)
          return callback()
        })
     })
    }
  )
}

// NormalModule.js
needBuild(context, callback) {
  // build if enforced
  if (this._forceBuild) return callback(null, true)

  // always build when module is not cacheable
  if (!this.buildInfo.cacheable) return callback(null, true)

  // build when there is no snapshot to check
  if (!this.buildInfo.snapshot) return callback(null, true)

  // build when valueDependencies have changed
  ...

  // 检查当前模块的 snapshot 来决定是否需要走 _doBuild 的流程
  // buildInfo 在持久化缓存的阶段也会被缓存下来
  // check snapshot for validity
  fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, (err, valid) => {
    if (err) return callback(err)
    if (!valid) return callback(null, true)
    const hooks = NormalModule.getCompilationHooks(compilation)
    hooks.needBuild.callAsync(this, context, (err, needBuild) => {
      if (err) {
        ...
      }
      callback(null, !!needBuild)
    })
  })
}


// IdleFileCachePlugin.js
const pendingIdleTasks = new Map()

compiler.cache.hooks.store.tap({
  name: 'IdleFileCachePlugin',
  state: Cache.STAGE_DISK
}, (identifier, etag, data) => {
  // 缓存相关的存储内容
  pendingIdleTasks.set(identifier, () => {
    strategy.store(identifier, etag, data)
  })
})

compiler.cache.hooks.shutdown.tapPromise({
  name: 'IdleFileCachePlugin',
  state: Cache.STAGE_DISK
}, () => {
  ...
  const jobs = Array.from(pendingIdleTasks.values())
  const promises = jobs.map(fn => fn())
  pendingIdleTasks.clear()
  promises.push(currentIdlePromise)
  const promise = Promise.all(promises)
  // 所有的 pendingIdleTasks 执行完后开始做存储相关的工作
  currentIdlePromise = promise.then(() => strategy.afterAllStored())
})
```

和缓存有关的几个内部插件：

// type: 'fileSystem' (in a layered way 分层的方式启用文件系统缓存和内存缓存)

* IdleFileCachePlugin
* PackFileCacheStrategy.js

// type: 'memory'

* MemoryWithGcCachePlugin
* MemoryCachePlugin

`compilation.fileSystemInfo.createSnapshot`

```javascript
// fileDependencies 文件依赖，对于一些构建出来的虚拟模块，需要注意其对应的依赖路径
this.watch(
  compilation.fileDependencies,
  compilation.contextDependencies,
  compilation.missingDependencies
)
```

2. 持久化缓存

webpack5 规范了持久化缓存的接口定义，在内置的 module/dependency 上都部署了持久化缓存的接口，例如 `EntryDependency` 入口依赖：

```javascript
// EntryDependency.js
class EntryDependency extends ModuleDependency {
  constructor(request) {
    super(request)
  }

  get type() {
    return 'entry'
  }

  get category() {
    return 'esm'
  }
}

// 调用 makeSerializeable 方法完成这个依赖的序列化接口注册，同时这个依赖上还完成了对于序列化接口的定义
makeSerializeable(EntryDependency, 'webpack/lib/dependencies/EntryDependency')

module.exports = EntryDependency

// ModuleDependency.js
class ModuleDependency extends Dependency {
  ...
  serialize(context) {
    const { write } = context
    write(this.request)
    write(this.userRequest)
    write(this.range)
    super.serialize(context)
  }

  deserialize(context) {
    const { read } = context
    this.request = read()
    this.userRequest = read()
    this.range = read()
    super.deserialize(context)
  }
}
```

```javascript
// makeSerializeable.js
class ClassSerializer {
  constructor(Constructor) {
    this.Constructor = Constructor
  }

  serialize(obj, context) {
    obj.serialize(context)
  }

  deserialize(context) {
    if (typeof this.Constructor.deserialize === 'function') {
      
    }
    const obj = new this.Constructor()
    obj.deserialize(context)
    return obj
  }
}
```

一些中间态数据走持久化缓存

1. snapshot 配置

snapshot 配置决定了不同类型的缓存策略，也是缓存是否失效的判断依据。

`cache.buildDependencies` 和 `snapshot.buildDependencies` 的含义并不一致。`cache.buildDependencies` 是将哪些文件 or 目录作为 `buildDependencies`(webpack 内部会默认将所有的 `loader` 作为 `buildDependencies`) 而 `snapshot.buildDependencies` 是定义这些 `buildDependencies` 创建 `snapshot` 的方式(`hash/timestamp`)。

todo: `fileSystemInfo.checkSnapshotValid` 根据 snapshot 是否发生变化来决定是否需要重新编译。这块和依赖之间的先后关系是怎么处理的？

watch 阶段对比 snapshot：文件的变化触发新的一次 compilation，在 `module.needBuild` 中根据 snapshot 来判断是否需要重新走编译的流程，这个时候内存当中的 `_snapshotCache` 虽然存在，但是以 Object 作为 key 的 Map 获取 `module.buildInfo.snapshot` 阶段的时候为 `undefined`，因此还是会进行 `_checkSnapshotValidNoCache`，实际上 `snapshot` 信息一方面被持久化缓存到磁盘当中，此外在生成 snapshot 的阶段时，内存当中也缓存了不同 module 的 timestamp、content hash 这些信息，所以在 `_checkSnapshotValidNoCache` 执行的阶段也是优先从缓存当中获取这些信息并进行对比。

第二次热启动对比 snapshot ：内存当中的 `_snapshotCache` 已经不存在，首先从缓存当中读取 `module.buildInfo.snapshot` 快照的内容，然后进行 `_checkSnapshotValidNoCache`

可以关注下 `normalization.js` 有关 webpack config 配置

```javascript
const path = require('path')
module.exports = {
  // ...
  snapshot: {
    // 针对包管理器维护存放的路径，如果相关依赖命中了这些路径，那么他们在创建 snapshot 的过程当中不会将 timestamps、content hash 作为 snapshot 的创建方法，而是 package 的 version
    managedPaths: [path.resolve(__dirname, '../node_modules')],
    immutablePaths: [],
    // 对于 buildDependencies snapshot 的创建方式
    buildDependencies: {
      // hash: true
      timestamp: true
    },
    // 针对单个 module 创建 snapshot 的方式
    module: {
      // hash: true
      timestamp: true
    },
    // 在 resolve request 的时候创建 snapshot 的方式
    resolve: {
      // hash: true
      timestamp: true
    },
    // 在 resolve buildDependencies 的时候创建 snapshot 的方式
    resolveBuildDependencies: {
      // hash: true
      timestamp: true
    }
  }
}
```

snapshot 的生成一般都对 fileDependencies、contextDependencies、missingDependencies 有依赖。

```javascript
// FileSystemInfo.js 提供了 createSnashot 的方法
class FileSystemInfo {
  // files 依赖的文件
  // directories 依赖的目录
  createSnapshot (startTime, files, directories, missing, options, callback) {
    ...
    const snapshot = new Snapshot()

    /** 1 = timestamp, 2 = hash, 3 = timestamp + hash */
		const mode = options && options.hash ? (options.timestamp ? 3 : 2) : 1;

    ...
    const checkManaged = (path, managedSet) => {
      for (const immutablePath of this.immutablePathsRegExps) {
				if (immutablePath.test(path)) {
					managedSet.add(path);
					return true;
				}
			}
			for (const immutablePath of this.immutablePathsWithSlash) {
				if (path.startsWith(immutablePath)) {
					managedSet.add(path);
					return true;
				}
			}
			for (const managedPath of this.managedPathsRegExps) {
				const match = managedPath.exec(path);
				if (match) {
					const managedItem = getManagedItem(match[1], path);
					if (managedItem) {
						managedItems.add(managedItem);
						managedSet.add(path);
						return true;
					}
				}
			}
			for (const managedPath of this.managedPathsWithSlash) {
				if (path.startsWith(managedPath)) {
					const managedItem = getManagedItem(managedPath, path);
					if (managedItem) {
						managedItems.add(managedItem);
						managedSet.add(path);
						return true;
					}
				}
			}
			return false;
    }
    const captureNonMananged = (items, managedSet) => {
      const capturedItems = new Set();
			for (const path of items) {
				if (!checkManaged(path, managedSet)) capturedItems.add(path);
			}
			return capturedItems;
    }
  }
  if (files) {
    // do something
  }
  if (directories) {
    // do something
  }
  if (missing) {
    // do something
  }
}
```

## 面对开发者而言

## 面对使用者而言