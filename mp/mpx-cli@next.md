# mpx-cli@next 插件化改造

## 背景 & 现状

`@mpxjs/cli@2.x` 版本整体是基于模板配置的方式完成项目的初始化，整个的工作流是：

下载一份存放于远端的 mpx 项目原始模板（mpx-template） -> 根据用户的 prompts 选项完成用户选项的注入

完成项目的初始化后，除了一些基础配置文件外，整个项目的文件主要包含了如下的结构：

```javascript
-- mpx-cube-ui
 |-- src // 项目源码
 |-- config // 项目配置文件
   |-- dll.config.js
   |-- index.js
   |-- mpxLoader.conf.js // mpx-loader 配置
   |-- mpxPlugin.conf.js // mpx webpack-plugin 配置
   |-- user.conf.js // 用户的 prompts 选择信息
 |-- build // 编译构建配置
   |-- build.js
   |-- getPlugins.js
   |-- getRules.js
   |-- getWebpackConf.js
   |-- utils.js
   |-- webpack.base.conf.js
```

在初始化的项目当中，有关项目的所有配置文件，编译构建代码是全部暴露给开发者的，开发者可以对这些文件进行修改来满足自己实际的项目开发需要。同时还可以基于这一套原始的模板文件二次拓展为满足自己业务场景的模板。

基于远程模板初始化项目的方式最大的一个好处就是将项目所有的底层配置完全暴露给开发者，开发者可以任意去修改对应的配置。

但是目前 `@mpxjs/cli@2.x` 采用这种基于模板的方式面临着这样的一些问题：

1. 对于 `@mpxjs/cli` 的用户而言：

*  如果远程模板的维护者如果对远程模板(mpx-template)进行了更新，对于用户来说没有一个很好的方式完成升级工作，基本只能通过 copy 代码的方式，将 `mpx-template` 更新后的内容复制一份到自己的项目当中；

* `@mpxjs/cli` 提供的是大而全的能力，从项目结构角度来说没法做到按需。例如我需要开发一个小程序，但是像 `dll` 这种增强的功能或者是没有使用到的小程序插件的构建配置都会出现在生成项目当中(虽然通过一些配置在构建过程中关闭了这些功能)。那么用户在进行编译打包构建配置的时候需要花些时间去理解整个的配置生成过来，来决定到底需要在哪里进行改造。


2. 对于 `@mpxjs/cli` 的开发者而言：

* 分支场景多，功能模块耦合度高：脚手架的所有功能全部集合到一个大的模板当中。各部分的能力都是耦合在一起，为了满足不同项目的实际开发需要，代码里面需要写比较多的 `if...else...` 判断逻辑来决定要开启哪些功能。


## 解决方案

`vue` 在2年前发布了 `@vue/cli@3.x`。和 `2.x` 版本相比而言，整个 `@vue/cli` 的架构发生了非常大的变化，从基于模板的脚手架迭代为基于插件化的脚手架。简单的概述下整个的构架就是：


## 改造细节

### 模块拆分

从跨平台的角度出发：

1. web 开发

2. 小程序开发

* 基于 `wx` 的跨平台(`ali`、`swan`，`tt`)的小程序开发；
* 使用云函数的微信小程序开发；
* 微信小程序的插件模式的开发；

公共能力：`dll`

基本上面提到的所有开发模式都对应了不同的目录结构以及编译构建配置。

### @vue/cli 能力复用

### 取舍