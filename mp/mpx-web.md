## Mpx 跨 web 方案的实现

整体上的实现思路是基于小程序的开发规范然后再做跨 web 的兼容。因为 mpx 也是采用 sfc 方式去组织文件内容（包括template/script/style/json），底层框架是基于 vue。

编译环节：

在编译环节需要解决的一个核心问题就是 mpx sfc 如何转化为 vue sfc，在这一层处理完之后，后面的编译构建流程即可直接复用 vue-loader（即 vue 项目的编译构建）的构建流程。

本地编译启动后，mpx 文件依然会走主 mpx loader，只不过在 mpx loader 内部针对 web 环境下的编译工作做了一些特殊处理：

对于项目的入口文件，注入 vue 以及项目的初始化渲染代码

对于非入口文件，例如通过 createPage 或者 createComponent 创建的页面/组件(在 vue 里面是没有 page 概念的，一切都是组件)，便需要处理 template/script/style/json 这些 block 的内容，特别是 json 配置只是在小程序里面独有的（主要是申明一些组件的依赖路径或者其他的配置），这也是和 vue sfc 里面差异非常大的点(vue sfc 里面组件依赖的申明是在 components 字段里面申明的)，所以 mpx sfc 转为 vue sfc 这个点来说，需要在编译环节处理为满足 vue sfc 文件开发规范的内容。

对于 template 来说，需要解决的3个重要的问题：

1. 基于小程序语法规范写的 template 标签语法如何和 web 拉齐；
2. 小程序的指令如何和 vue directive 拉齐；
3. 事件处理；

其中第一个点，在小程序开发规范当中，每一个标签元素其实都是一个内置组件，小程序对这些内置组件做了一定程度的封装，内置组件有自己的功能特性、样式规则、事件绑定等等，我们平时开发组件都是基于这些内置组件来进行开发的。在做 web 开发一样，浏览器提供了 `div`、`input`、`button` 等这些内置组件，只不过封装程度，提供的功能特性没有小程序提供的那么多。那么如果要做跨 web 的输出的话，最终的目标肯定是小程序和 web 渲染都是一致的，也就是在小程序使用一个内置的 button 组件，在 web 侧需要对应的实现其功能。因此在标签语法的处理流程中是通过收集&标记 template 当中使用到了哪些内置基础组件（内置组件都是全局的），渲染阶段其实是将渲染这些内置组件所对应在 vue 侧实现的自定义组件。最终达到的效果就是在小程序渲染的基础组件和 web 侧渲染出来的都是一致的。

对于第二个点，小程序对于模板语法做了一定程度的增强，提供了一些可以提高开发效率&体验的 directive，例如条件渲染(wx:if)，列表渲染等(wx:for)，而在 vue 当中不仅仅提供了条件渲染、列表渲染还有一些对于 class，style，show 等非常好用的一些指令。所以在这部分的处理过程当中，首先是对于2个平台上已有指令的对齐（wx:if -> v-if），另外一个点就是对于小程序的指令系统做增强，即在小程序的规范生态下通过编译 + runtime 配合来达到实现小程序没有但是 vue 里面有的功能。所以在使用 mpx 进行小程序开发的过程中，可以使用一些原生小程序没有提供的增强型的指令。

对于第三点，


运行时环节：

在运行时环节需要解决的问题：

1. 文件的导入导出；
2. 生命周期


MpxWebpackPlugin.loader()  -> processTemplate(完成 builtInComponentsMap 的收集) -> processScript