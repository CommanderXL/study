## 循环依赖

Es Module 和 CommonJS 规范都支持循环依赖。不过2个规范对于模块的加载和执行的策略不一样，所以在实际场景当中如果遇到了循环依赖的情况的话，

CommonJS 规范从加载策略来说是运行时加载，即代码执行到需要加载模块的那一行代码的时候，才会去加载并执行对应依赖的模块。举个例子：

`foo.js`和`bar.js`形成了一个循环依赖。这里可以看到`foo.js`**导出变量书写的位置**直接影响到了`bar.js`代码的执行。当`bar.js`开始执行的时候，如果在`foo.js`还未执行到`exports.setFooParams`导出这个方法的时候，在`bar.js`里面是访问不到对应方法的，这样程序执行的时候也就会报错。那么规避这种情况的一个处理方法就提前将`exports.setFooParams`方法置于文件的顶部，提前导出。

```javascript
// foo.js
const { setBarParams } = require('./bar')
const params = {}

exports.setFooParams = function (obj) {
  Object.assign(params, obj);
}

setBarParams({ a: 1 });



// bar.js
const { setFooParams } = require('./foo')

const params = {};

exports.setBarParams = function (obj) {
  Object.assign(params, obj);
}


setFooParams({ b: 2 });
```

Es Module 规范当中，规定使用 import 来导入模块，export 来导出模块的接口，导出的变量或方法为引用类型，这也是和 CommonJS 规范导出变量为值拷贝的不同点之一。Es Module 在代码的静态编译阶段就确定了模块之间的相互依赖关系，在 Es Module 执行的过程中，import 导入模块有提升的效果，即在一个文件当中，可能你的导入的其他模块的代码是在文件的下方，但是在实际执行的过程当中首先会执行 import 导入模块的代码的。