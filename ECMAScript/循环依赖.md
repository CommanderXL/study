# 循环依赖

## Es Module 和 CommonJS 对于循环依赖功能支持的执行策略

Es Module 和 CommonJS 规范都支持循环依赖。不过2个规范对于模块的加载和执行的策略不一样，所以在实际场景当中如果遇到了循环依赖的情况的话，

CommonJS 规范从加载策略来说是运行时加载，即代码执行到需要加载模块的那一行代码的时候，才会去加载并执行对应依赖的模块。举个例子：

`foo.js`和`bar.js`形成了一个循环依赖。这里可以看到`foo.js`**导出变量书写的位置**直接影响到了`bar.js`代码的执行。当`bar.js`开始执行的时候，如果在`foo.js`还未执行到`exports.setFooParams`导出这个方法的时候，在`bar.js`里面是访问不到对应方法的，这样程序执行的时候也就会报错。那么规避这种情况的一个处理方法就提前将`exports.setFooParams`方法置于文件的顶部，提前导出。

```javascript
// foo.js
const { setBarParams } = require('./bar')
const params = {}

exports.setFooParams = function (obj) {
  Object.assign(params, obj);
}

setBarParams({ a: 1 });



// bar.js
const { setFooParams } = require('./foo')

const params = {};

exports.setBarParams = function (obj) {
  Object.assign(params, obj);
}


setFooParams({ b: 2 });
```

Es Module 规范当中，规定使用 import 来导入模块，export 来导出模块的接口，导出的变量或方法为引用类型，这也是和 CommonJS 规范导出变量为值拷贝的不同点之一。Es Module 在代码的静态编译阶段就确定了模块之间的相互依赖关系，在 Es Module 执行的过程中，import 导入模块有提升的效果，即在一个文件当中，可能你的导入的其他模块的代码是在文件的下方，但是在实际执行的过程当中首先会执行 import 导入模块的代码的。因为这样的特性，在 Es Module 当中如果遇到了循环依赖的情况：

```javascript
// a.js
console.log('this is a file')

import { setBParams } from './b'
var params = {}

export function setAParams(obj) {
  Object.assign(params, obj)
}

setBParams({ a: 1 })


// b.js
var params = {}

import { setAParams } from './a'

export function setBParams(obj) {
  Object.assign(params, obj)
}

console.log('this is b file')
setAParams({ b: 2 })
```

开始执行`a.js`代码的时候，实际上会先执行`b.js`的代码，在`b.js`当中当执行到`setAParams`方法的时候，在`a.js`里面`params`变量仅仅完成了申明，还未走到赋值的阶段，因此会在`setAParams`调用的时候出现报错的情况。

## 案例

一般在书写代码的过程中不会特别留心有关 ES Module 出现循环依赖的场景，不过随着项目的迭代和应用代码的增加，以及不同的开发人员参与到项目的开发迭代当中，如果对于模块之间的相互引用关系不清晰或者是在模块设计开发阶段没有做好合理的规划，在日后的开发过程中还是会比较容易出现这种循环依赖的场景。

接下来简单总结下最近在开发过程中遇到循环依赖这一问题以及针对这个问题如何解决的。

在我们日常的开发过程当中，将一些通用的功能抽离成 sdk 单独的去维护。sdk 内部的模块是以职责功能维度去进行划分的：

* Init 模块：基础通用参数的初始化相关；
* Ajax 模块：接口请求相关；
* Login 模块：登录相关；
* Omega 模块：埋点相关；

这里暂且将 Init、Login、Omega、Ajax 分别成为一级模块。然后每个一级模块内部可能还会进行相关子模块(二级模块)的拆解，例如 Init 模块里面包含了：

* 和 native 侧交互的 bridge 的初始化及相关通用参数的初始化；
* url 上的 query 参数作为埋点、接口请求的公参初始化；
* 一些需要全局挂载的对象实例等；

Ajax 模块里包含了：

* Error 处理；
* 基础 Http 方法请求封装；
* 拦截器；

当然每个模块是有一级导出(`index.js`文件一般会集合不同的二级模块并将它们导出)的，不同模块之间有相互引用关系，例如 Ajax 模块可能会使用 Init 模块当中提供的一些公参。


目前 Init 模块的一级导出变得越来越臃肿。