## 循环依赖

Es Module 和 CommonJS 规范都支持循环依赖。不过2个规范对于模块的加载和执行的策略不一样，所以在实际场景当中如果遇到了循环依赖的情况的话，

CommonJS 规范从加载策略来说是运行时加载，即代码执行到需要加载模块的那一行代码的时候，才会去加载并执行对应依赖的模块。举个例子：

`foo.js`和`bar.js`形成了一个循环依赖。这里可以看到`foo.js`**导出变量书写的位置**直接影响到了`bar.js`代码的执行。当`bar.js`开始执行的时候，如果在`foo.js`还未执行到`exports.setFooParams`导出这个方法的时候，在`bar.js`里面是访问不到对应方法的，这样程序执行的时候也就会报错。那么规避这种情况的一个处理方法就提前将`exports.setFooParams`方法置于文件的顶部，提前导出。

```javascript
// foo.js
const { setBarParams } = require('./bar')
const params = {}

exports.setFooParams = function (obj) {
  Object.assign(params, obj);
}

setBarParams({ a: 1 });



// bar.js
const { setFooParams } = require('./foo')

const params = {};

exports.setBarParams = function (obj) {
  Object.assign(params, obj);
}


setFooParams({ b: 2 });
```

Es Module 规范当中，规定使用 import 来导入模块，export 来导出模块的接口，导出的变量或方法为引用类型，这也是和 CommonJS 规范导出变量为值拷贝的不同点之一。Es Module 在代码的静态编译阶段就确定了模块之间的相互依赖关系，在 Es Module 执行的过程中，import 导入模块有提升的效果，即在一个文件当中，可能你的导入的其他模块的代码是在文件的下方，但是在实际执行的过程当中首先会执行 import 导入模块的代码的。因为这样的特性，在 Es Module 当中如果遇到了循环依赖的情况：

```javascript
// a.js
console.log('this is a file')

import { setBParams } from './b'
var params = {}

export function setAParams(obj) {
  Object.assign(params, obj)
}

setBParams({ a: 1 })


// b.js
var params = {}

import { setAParams } from './a'

export function setBParams(obj) {
  Object.assign(params, obj)
}

console.log('this is b file')
setAParams({ b: 2 })
```

开始执行`a.js`代码的时候，实际上会先执行`b.js`的代码，在`b.js`当中当执行到`setAParams`方法的时候，在`a.js`里面`params`变量仅仅完成了申明，还未走到赋值的阶段，因此会在`setAParams`调用的时候出现报错的情况。

* 出现循环依赖的场景
* 对于循环依赖场景的解决方案