## 父子组件通讯

在`Vue`中，父子组件基本的通讯方式就是父组件通过`props`属性将数据传递给子组件，这种数据的流向是单向的，当父`props`属性发生了改变，子组件所接收到的对应的属性值也会发生改变，但是反过来却不是这样的。子组件通过`event`自定义事件的触发来通知父组件自身内部所发生的变化。

还是从一个实例出发：

```javascript
// 模板
<div id="app">
  <child-component :message="val"></child-component>
</div>


// js

Vue.component('child-component', {
  props: ['message']
  template: '<div>this is child component, I have {{message}}</div>',
})

new Vue({
  el: '#app',
  data() {
    return {
      val: 'parent val'
    }
  },
  mounted () {
    setTimeout(() => {
      this.val = 'parent val which has been changed after 2s'
    }, 2000)
  }
})
```

最终页面渲染出的内容为:

```javascript
this is child component, I have parent val

2s后文案变更为：
this child component, I hava parent val which has been changed after 2s 
```

接下来我们就来看下父子组件是如何通过`props`属性来完成数据的传递的。

首先根组件开始实例化，完成一系列的初始化的内容。首先将`val`转化为响应式的数据，并调用`Vue.prototype.$mount`方法完成

```javascript
Vue.prototype._init = function (options) {
  ...
  initState(vm)
  
  ...
  if (vm.$options.el) {
    vm.$mount(vm.$options.el);
  }
  ...
}
```

`Vue.prototype.$mount`方法内部：
```javascript
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);
  
  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      ...
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      ...
      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      // 生成render函数
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
    }
  }
  return mount.call(this, el, hydrating)
};

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    ...
  }
  // 挂载前
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    ...
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}
```

完成模板的编译，同时生成`render`函数，这个`render`函数在实际实行生成`vnode`时，会将作用域绑定到对应的`vue`实例的作用域下，即在创建`vnode`的环节当中，始终访问的是当前这个`vue`实例，子`vnode`创建时是没法直接访问到父组件中定义的数据的。除非通过`props`属性来完成数据由父组件向子组件的传递。

```javascript
(function() {
  with (this) {
    return _c('div', {
        attrs: {
          "id": "app"
        }
      }, [_c('my-component', {
          attrs: {
            "message": val
          }
      })], 1)
   }
  }
)

```
完成模板的编译生成`render`函数后，调用`_c`方法，对应访问`vue`实例的`_c`方法，开始创建对应的`vnode`，注意这里`val`变量，即`vue`实例上`data`属性定义的`val`，在创建对应的`vnode`前，实例已经调用`initState`方法将`val`转化为响应式的数据。因此在创建`vnode`过程中，访问`val`即访问它的`getter`。

在访问过程中`Dep.target`已经被设定为当前`vue`实例的`watcher`(具体见`mountComponent`方法内部创建`watcher`对象)，因此会将当前的`watcher`加入到`val`的`dep`当中。这样便完成了`val`的依赖收集的工作。

在创建`VNode`时，又分为：

* 内置标签(即标准规定的标签)元素的VNode
* 本文要讨论的自定义的标签元素的VNode

其中内置标签的`VNode`的没有需要特别说明的地方，就是调用`VNode`的构造函数完成创建过程。

但是在创建自定义标签元素的`VNode`时，完成一些重要的操作(因为本文是讲解props传递，所以挑出和props相关的部分)：

```javascript
function createComponent () {

  ...
  // 注意这个方法。它完成了从父组件对应的props字段获取值的作用，具体到本例子，就是获取到了message字段的值
  // 这样就完成了props从父组件传递到子组件的功能
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
  ...

  // 给component初始化挂载钩子函数，只有自定义的component才有，built-in的没有
  installComponentHooks(data);
  ...
  // 创建VNode
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
  return vnode
}


```



当完成了`my-component`的`VNode`创建后，开始创建它的父`VNode`，即根`VNode`。

当`VNode`都创建完成后，开始递归将`VNode`渲染成真实的`dom`节点，同时挂载到`document`当中(见上方调用的`mountComponent`内部`vm.update(vm._render())`)。

在将`VNode`渲染成真实的`dom`节点过程当中。

```javascript
Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      // 触发beforeUpdate钩子函数
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // 第一次渲染
    if (!prevVnode) {
      // initial render
      // 初始化render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      ...
    } else {
      // updates
      // 将prevVnode和vnode进行patch操作并更新
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    ...
  }
```

// vm._update(vm._render())
// patch
// prepatch方法
// updateChildComponent完成props等属性的setter操作