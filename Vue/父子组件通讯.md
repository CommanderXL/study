## 父子组件通讯

在`Vue`中，父子组件基本的通讯方式就是父组件通过`props`属性将数据传递给子组件，这种数据的流向是单向的，当父`props`属性发生了改变，子组件所接收到的对应的属性值也会发生改变，但是反过来却不是这样的。子组件通过`event`自定义事件的触发来通知父组件自身内部所发生的变化。

还是从一个实例出发：

```javascript
// 模板
<div id="app">
  <child-component :message="val"></child-component>
</div>


// js

Vue.component('child-component', {
  props: ['message']
  template: '<div>this is child component, I have {{message}}</div>',
})

new Vue({
  el: '#app',
  data() {
    return {
      val: 'parent val'
    }
  },
  mounted () {
    setTimeout(() => {
      this.val = 'parent val which has been changed after 2s'
    }, 2000)
  }
})
```

最终页面渲染出的内容为:

```javascript
this is child component, I have parent val

2s后文案变更为：
this child component, I hava parent val which has been changed after 2s 
```

接下来我们就来看下父子组件是如何通过`props`属性来完成数据的传递的。


首先根组件开始实例化，完成一系列的初始化的内容。首先将`val`转化为响应式的数据，并调用`Vue.prototype.$mount`方法完成

```javascript
Vue.prototype._init = function (options) {
  ...
  initState(vm)
  
  ...
  if (vm.$options.el) {
    vm.$mount(vm.$options.el);
  }
  ...
}
```

`Vue.prototype.$mount`方法内部：
```javascript
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  
  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      ...
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      ...
      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      // 生成render函数
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;                    // 挂载render函数
      options.staticRenderFns = staticRenderFns;  // 挂载staticRenderFns函数
    }
  }
  return mount.call(this, el, hydrating)
};
```

完成模板的编译，同时生成`render`函数，这个`render`函数在实际实行生成`vnode`时，会将作用域绑定到对应的`vue`实例的作用域下，即在创建`vnode`的环节当中，始终访问的是当前这个`vue`实例，子`vnode`创建时是没法直接访问到父组件中定义的数据的。除非通过`props`属性来完成数据由父组件向子组件的传递。

```javascript
(function() {
  with (this) {
    return _c('div', {
        attrs: {
            "id": "app"
        }
      }, [_c('my-component', {
          attrs: {
              "message": val
          }
      })], 1)
   }
  }
)

```


// vm._update(vm._render())
// patch
// prepatch方法
// updateChildComponent完成props等属性的setter操作