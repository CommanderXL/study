## 父子组件通讯

在`Vue`中，父子组件基本的通讯方式就是父组件通过`props`属性将数据传递给子组件，这种数据的流向是单向的，当父`props`属性发生了改变，子组件所接收到的对应的属性值也会发生改变，但是反过来却不是这样的。子组件通过`event`自定义事件的触发来通知父组件自身内部所发生的变化。

还是从一个实例出发：

```javascript
// 模板
<div id="app">
  <child-component :message="val"></child-component>
</div>


// js

Vue.component('child-component', {
  props: ['message']
  template: '<div>this is child component, I have {{message}}</div>',
})

new Vue({
  el: '#app',
  data() {
    return {
      val: 'parent val'
    }
  },
  mounted () {
    setTimeout(() => {
      this.val = 'parent val which has been changed after 2s'
    }, 2000)
  }
})
```

最终页面渲染出的内容为:

```javascript
this is child component, I have parent val

2s后文案变更为：
this child component, I hava parent val which has been changed after 2s 
```

接下来我们就来看下父子组件是如何通过`props`属性来完成数据的传递的。

首先根组件开始实例化，完成一系列的初始化的内容。首先将`val`转化为响应式的数据，并调用`Vue.prototype.$mount`方法完成

```javascript
Vue.prototype._init = function (options) {
  ...
  initState(vm)
  
  ...
  if (vm.$options.el) {
    vm.$mount(vm.$options.el);
  }
  ...
}
```

`Vue.prototype.$mount`方法内部：
```javascript
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);
  
  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      ...
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      ...
      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      // 生成render函数
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
    }
  }
  return mount.call(this, el, hydrating)
};

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    ...
  }
  // 挂载前
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    ...
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}
```

完成模板的编译，同时生成`render`函数，这个`render`函数在实际实行生成`vnode`时，会将作用域绑定到对应的`vue`实例的作用域下，即在创建`vnode`的环节当中，始终访问的是当前这个`vue`实例，子`vnode`创建时是没法直接访问到父组件中定义的数据的。除非通过`props`属性来完成数据由父组件向子组件的传递。

```javascript
(function() {
  with (this) {
    return _c('div', {
        attrs: {
            "id": "app"
        }
      }, [_c('my-component', {
          attrs: {
              "message": val
          }
      })], 1)
   }
  }
)

```
完成模板的编译生成`render`函数后，调用`_c`方法，对应访问`vue`实例的`_c`方法，开始创建对应的`vnode`，注意这里`val`变量，即`vue`实例上`data`属性定义的`val`，在创建对应的`vnode`前，实例已经调用`initState`方法将`val`转化为响应式的数据。因此在创建`vnode`过程中，访问`val`即访问它的`getter`。

// vm._update(vm._render())
// patch
// prepatch方法
// updateChildComponent完成props等属性的setter操作